#pragma config(Motor,  port2,           leftMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           rightMotor,    tmotorServoContinuousRotation, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

typedef enum{
    north,
    east,
    south,
    west
} Direction;

void turnRight(int degrees){
 motor[leftMotor] = 90;
  motor[rightMotor] = -90;
   for (int i = 0; i < degrees*1.4; i++){
       wait10Msec(1);
    }
}

void turnLeft(int degrees){
    motor[leftMotor] = -90;
    motor[rightMotor] = 90;
    for (int i = 0; i < degrees*1.2; i++){
        wait10Msec(1);
    }
}

/*int[][] generateMap(string listOfCommands){
    Direction currDirection = south;
    int strLength = strLen(listOfCommands);
    //Can never be larger than list of commands itself
    int[strLength][strLength] map;
    char[strLength] str;
    int currX = 0;
    int currY = 0;
    memcpy(listOfCommands, str, sizeof(listOfCommands));
    for (int i = 0; i < strLength; i++){
        switch (str[i]){
            case '0':
                switch (currDirection){
                    case south:
                        map[currX][currY+1] = 0;
                        currY++;
                        break;
                    case north:
                        map[currX][currY-1] = 0;
                        currY--;
                        break;
                    case west:
                        map[currX+1][currY] = 0;
                        currX++;
                        break;
                    case east:
                        map[currX-1][currY] = 0;
                        currX--;
                        break;
                }
                break;
            case '1':
                switch (currDirection){
                    case south:
                        map[currX][currY+1] = 1;
                        break;
                    case north:
                        map[currX][currY-1] = 1;
                        break;
                    case west:
                        map[currX+1][currY] = 1;
                        break;
                    case east:
                        map[currX-1][currY] = 1;
                        break;
                }
                break;
            case 'r':
                if (currDirection >= west){
                    currDirection = north;
                }
                else{
                    ++currDirection;
                }
                break;
            case 'l':
                if (currDirection <= north){
                    currDirection = west;
                }
                else{
                    --currDirection;
                }
                break;
        }
    }
}*/

int formatArr(char **listofCommands, char ***newList, int length){
    int count = 0;
    char* bufferStr;
    for (int i = 0; i < length; i++){
        if (atoi(strIndex(listOfCommands[0],i)) == 0){
            *newList[count] = bufferStr;
            count++;
            *newList[count] = *listOfCommands[i];
            count++;
            bufferStr = NULL;
        }
        else{
            strcat(bufferStr, *listOfCommands[i]);
        }
    }
    return count;
}

void navigate(char **listOfCommands, int length){
    /*int[][] mapOfPos = generateMap(listOfCommands);*/
    char** newList;
    int newLength = formatArr(listOfCommands, &newList, length);
    for (int i = 0; i < newLength; i++){
            if (strcmp(newList[i],"L") == 0){
                turnLeft(90);
            }
            else if(strcmp(newList[i],"R") == 0){
                //Turn right
                turnRight(90);
            }
            else if(strcmp(newList[i], "G") == 0){
                break;
            }
            else{
                //Go forwards certain amount.
            }
        }
    }
}

task main()
{
    turnLeft(180);
    turnRight(180);

    char* stream;
    configureSerialPort (uartOne, uartUserControl);
    setBaudRate(uartOne, baudRate9600);
    while (getChar(uartOne) != -1);
    while (true){
        char incomingChar = getChar(uartOne);
        if (incomingChar == 'G'){
            navigate(&stream, strlen(stream));
        }
        else{
            strcat(stream, &incomingChar);
        }
    }

}
